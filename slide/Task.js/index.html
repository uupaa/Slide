<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">

<title>Task.js</title>

<meta name="description" content="Task.js">    

  <meta name="author" content="A very simple way to wait for asynchronius processes." />

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/default.css" id="theme">


<!-- For syntax highlighting -->
  <link rel="stylesheet" href="lib/css/zenburn.css">


<!-- If the query includes 'print-pdf', use the PDF print sheet -->
<script>
  document.write( '<link rel="stylesheet" href="css/print/' +
    ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + 
    '.css" type="text/css" media="print">' );
</script>

<script src="../../assets/js/Valid.js"></script>
<script src="../../assets/js/Help.js"></script>
<script src="../../assets/js/Task.js"></script>

<!--[if lt IE 9]>
<script src="lib/js/html5shiv.js"></script>
<![endif]-->
</head>

<body>

<div class="reveal">

<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">

<section>
<h1>Task.js</h1>
<h3>A very simple way to wait for asynchronius processes.</h3>
<p>
<h4><span class="citation" data-cites="uupaa">@uupaa</span> - 2014-02-14 (rev 2)</h4>
</p>
</section>  


<!-- ----------------------------------------------------- -->

<!-- ----------------------------------------------------- -->

<section id="javascript-async-idiom" class="level1">
<h1>JavaScript, Async, Idiom</h1>
<section id="javascript-は非同期処理の塊" class="level2">
<h2>JavaScript は非同期処理の塊</h2>
<ul>
<li>XHR</li>
<li>onload</li>
<li>setTimeout</li>
<li>postMessage</li>
<li>addEventListener</li>
<li>DOMContentLoaded</li>
</ul>
</section>
<section id="section" class="level2">
<h2></h2>
<p>非同期プログラミングを<br />支援するライブラリやイディオムは、<br />Deferred, Promises, async, await,<br />DOM Promise など沢山がありますが…</p>
</section>
<section id="section-1" class="level2">
<h2></h2>
<p>ここで紹介する <strong><a href="https://github.com/uupaa/Task.js">Task.js</a></strong> も、非同期プログラミングを支援するライブラリです</p>
<hr />
<p>( Task.js は <strong><a href="http://www.slideshare.net/uupaa/flowjs">Flow.js</a></strong><a href="#section"></a> の改良版です )</p>
</section>
<section id="section-2" class="level2">
<h2></h2>
<p>Task.js は、どこでも動きます。</p>
<p><br /> ブラウザのサポート状況を気にしたり、<br />Polyfillライブラリの存在に左右されるような<br />不安定な状況から開放されます <br /></p>
<ul>
<li>環境依存なコードがある? ▶ ありません</li>
<li>複雑なトリックに依存してる? ▶ していません</li>
<li>Browser, WebWorkers, Node.js で動く? ▶ 動きます</li>
</ul>
</section>
<section id="section-3" class="level2">
<h2></h2>
<p>Task.js を導入すると、<br />非同期処理で悩む必要がなくなり、<br />ロジックの実装に集中できるようになります</p>
<ul>
<li>今後もずっと使える? ▶ 使えます</li>
<li>チームで使える? ▶ 使えます(導入も簡単です)</li>
<li>導入実績ある? ▶ あります</li>
<li>枯れてる? ▶ 枯れてます</li>
</ul>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="非同期処理へのneedsとwants" class="level1">
<h1>非同期処理へのNeedsとWants</h1>
<section id="複数の非同期処理の完了を待ちたい" class="level2">
<h2>複数の非同期処理の完了を待ちたい</h2>
<ul>
<li>ダウンロードの完了を待ちつつアニメーションしたい</li>
<li>いくつかの非同期処理をグルーピングし、 それらの終了を待ちたい事がよくある</li>
<li>同期/非同期が混在すると、場当たり的に、 一方はループで、一方はコールバックの連鎖で制御している</li>
<li>同期/非同期を意識せずに扱いたい</li>
<li>毎回同じようなコードを書いて捨てている気がする</li>
</ul>
</section>
<section id="シンプルで枯れた実装がほしい" class="level2">
<h2>シンプルで枯れた実装がほしい</h2>
<ul>
<li>Deferred や Promises を<br /> JavaScript に詳しくない人や、<br /> 非プログラマーに説明するのは骨が折れる</li>
</ul>
</section>
<section id="運用で困らないようにしたい" class="level2">
<h2>運用で困らないようにしたい</h2>
<ul>
<li>特定の環境に依存したり、頻繁に更新される重厚なライブラリには依存したくない(できない)</li>
</ul>
</section>
<section id="デバッグのしやすさも大事" class="level2">
<h2>デバッグのしやすさも大事</h2>
<ul>
<li>非同期処理に問題があることは分かったが、<br /> <strong>どの非同期処理で止まっているかが分からないと、<br /> 非常に困る</strong>、原因を素早く特定したい</li>
<li>実行中の同期/非同期関数をモニタリングしたい</li>
</ul>
</section>
<section id="仕様変更にも強い実装にしたい" class="level2">
<h2>仕様変更にも強い実装にしたい</h2>
<ul>
<li>UIアニメーションや、<br /> ゲームのアニメーションの流れや順番は、<br /> クオリティアップの段階で頻繁に修正が入るが、<br /> それらを仕様変更に強い形でデータ化<br /> またはコード化できないか</li>
<li>アニメーションの順番を変えたいだけなのに、<br /> コードをガバっと変更する感じの実装はつらい</li>
</ul>
</section>
<section id="section-4" class="level2">
<h2></h2>
<p>Task.js はこれら全ての<br /><strong>Needs</strong> と <strong>Wants</strong> を満たしてくれます</p>
<hr />
<p>では、Task.js の機能を見て行きましょう</p>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="task.js-の基本" class="level1">
<h1>Task.js の基本</h1>
<section id="section-5" class="level2">
<h2></h2>
<ol type="1">
<li>Task.js では、ユーザが用意する同期/非同期処理を<br /> <strong>ユーザータスク</strong> と呼びます</li>
<li>var task = new Task(<strong>2</strong>, <strong>callback</strong>) は、<br /> <strong>task.pass()</strong> が2回呼ばれるまで<strong>待機</strong>します</li>
</ol>
<pre class="js"><code>var task = new Task(2, callback); // 2つのユーザタスクの完了を待つ

userTask() ? task.pass() : task.miss(); // 同期ユーザタスク

setTimeout(function() {
    userTask() ? task.pass() : task.miss(); // 非同期ユーザタスク
}, 1000);

function userTask() { return Math.random() &gt;= 0.8; } // 80%の確率でtrueを返す

function callback(error) {
    console.log(&quot;finished&quot;);
}</code></pre>
</section>
<section id="section-6" class="level2">
<h2></h2>
<ol start="3" type="1">
<li><strong>task.pass()</strong> を2回呼ぶと <strong>待機成功</strong> で終了します</li>
<li><strong>task.miss()</strong> を1回呼ぶと <strong>待機失敗</strong> で終了します</li>
<li>待機終了で callback が呼ばれます</li>
<li>callback( <strong>error</strong> ) の error は待機成功で null,<br /> 待機失敗で Error オブジェクトになります</li>
</ol>
<pre class="js"><code>var task = new Task(2, callback); // 2つのユーザタスクの完了を待つ

userTask() ? task.pass() : task.miss(); // 同期ユーザタスク

setTimeout(function() {
    userTask() ? task.pass() : task.miss(); // 非同期ユーザタスク
}, 1000);

function userTask() { return Math.random() &gt;= 0.8; } // 80%の確率でtrueを返す

function callback(error) {
    console.log(&quot;finished&quot;);
}</code></pre>
</section>
<section id="まとめ" class="level2">
<h2>まとめ</h2>
<ol type="1">
<li><strong>new Task</strong>(<strong>ユーザタスクの数</strong>, <strong>callback</strong>) で待機開始</li>
<li>成功で <strong>task.pass()</strong> を、失敗で <strong>task.miss()</strong> を呼ぶ</li>
<li>待機終了で <strong>callback</strong> が呼ばれる<br /> <strong>error</strong> が <strong>null</strong> で<strong>成功</strong></li>
</ol>
<hr />

<p>Task.js を使うために必要となる知識は<br />この3つだけです</p>
<hr />

<p>次のページからは、<br />さらに便利な使い方を紹介していきます</p>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="task.js-を便利に使う" class="level1">
<h1>Task.js を便利に使う</h1>
<section id="section-7" class="level2">
<h2></h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">用法</th>
<th style="text-align: left;">Task API</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">バッファに貯める</td>
<td style="text-align: left;">task.push(), task.set()</td>
</tr>
<tr class="even">
<td style="text-align: left;">バッファから取り出す</td>
<td style="text-align: left;">task.buffer(), callback(, buffer)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">データを変換する</td>
<td style="text-align: left;">Task.flatten(), Task.arraynize(), <br />Task.objectize()</td>
</tr>
<tr class="even">
<td style="text-align: left;">デバッグする</td>
<td style="text-align: left;">Task.dump(), Task.drop()</td>
</tr>
<tr class="odd">
<td style="text-align: left;">強制終了する</td>
<td style="text-align: left;">task.exit()</td>
</tr>
<tr class="even">
<td style="text-align: left;">状態を取得,終了を判定する</td>
<td style="text-align: left;">task.state(), task.isFinished()</td>
</tr>
<tr class="odd">
<td style="text-align: left;">エラーハンドリング</td>
<td style="text-align: left;">task.message(), task.done(error)</td>
</tr>
</tbody>
</table>
</section>
<section id="section-8" class="level2">
<h2></h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">用法</th>
<th style="text-align: left;">Task API</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">失敗を許容する</td>
<td style="text-align: left;">task.missable()</td>
</tr>
<tr class="even">
<td style="text-align: left;">もっと待機する</td>
<td style="text-align: left;">task.extend()</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Task を連結する</td>
<td style="text-align: left;">Junction</td>
</tr>
<tr class="even">
<td style="text-align: left;">並列/直列動作</td>
<td style="text-align: left;">Task.run()</td>
</tr>
<tr class="odd">
<td style="text-align: left;">非同期ループ</td>
<td style="text-align: left;">Task.loop()</td>
</tr>
</tbody>
</table>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="バッファに貯める取り出す" class="level1">
<h1>バッファに貯める/取り出す</h1>
<section id="buffer" class="level2">
<h2>buffer</h2>
<p>各Taskのインスタンスは<br /><strong>バッファ</strong>と呼ばれる配列を持っています</p>
<p><br /> バッファにはサーバから取得したリソースや、<br />計算途中の値などを入れておき、<br />待機終了後に取り出して利用します</p>
</section>
<section id="task.buffer-callback-buffer-task.push-task.set" class="level2">
<h2>task.buffer(), callback(, buffer), task.push(), task.set()</h2>
<ul>
<li><strong>task.buffer()</strong> で直接バッファにアクセスできます<br /></li>
<li>待機終了後は callback(, <strong>buffer</strong>) からアクセスできます</li>
<li><strong>task.push(value)</strong> は buffer.push(value) を行います</li>
<li><strong>task.set(key,value)</strong> は buffer[key] = value を行います</li>
</ul>
<pre class="js"><code>function callback(error, buffer) {
    console.log(buffer[0]);   // -&gt; &quot;value1&quot;
    console.log(buffer.key2); // -&gt; &quot;value2&quot;
}

var task = new Task(1, callback);

task.push(&quot;value1&quot;); // buffer に &quot;value1&quot; を追加する
task.set(&quot;key2&quot;, &quot;value2&quot;); // buffer に { &quot;key2&quot;: &quot;value2&quot; } をセット(上書き)する
task.pass();</code></pre>
</section>
<section id="shared-buffer" class="level2">
<h2>Shared Buffer</h2>
<pre class="js"><code>function callback(error, buffer) { // sharedBuffer: [&quot;junction&quot;, &quot;value1&quot;, &quot;value2&quot;]
    console.log(buffer.length); // -&gt; 3
}

var junction = new Task(2, callback).push(&quot;junction&quot;);
var task1    = new Task(1, junction);
var task2    = new Task(1, junction);

task1.push(&quot;value1&quot;).pass();
task2.push(&quot;value2&quot;).pass();</code></pre>
<ul>
<li>後述する Junction を使い、階層構造をもった Task は、<br /> お互いの <strong>buffer を共有した状態</strong> になります</li>
<li>task1.push(&quot;value1&quot;) は junction.push(&quot;value1&quot;) と <strong>同じ結果</strong> になり<br /> task2.push(&quot;value2&quot;) も junction.push(&quot;value2&quot;) と <strong>同じ結果</strong> になります</li>
</ul>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="データ変換" class="level1">
<h1>データ変換</h1>
<section id="task.flatten" class="level2">
<h2>Task.flatten()</h2>
<pre class="js"><code>var array = [ [1,2], [3,4] ];

Task.flatten(source); // -&gt; [1, 2, 3, 4]</code></pre>
<ul>
<li><strong>Task.flatten(source)</strong>を使うと、配列の次元数を -1 することができます</li>
<li>2次元配列は1次元配列に展開され、3次元配列は2次元配列に展開されます</li>
<li>多次元配列を含んだ source の値を展開する汎用関数として利用できます</li>
</ul>
<pre class="js"><code>// 3次元配列を展開
Task.flatten([ [1,2], [3,4], [ [5,6] ] ]); // -&gt; [ 1, 2, 3, 4, [5, 6] ]

// 2次元配列を展開
Task.flatten([  1,2,   3,4,    [5,6]   ]); // -&gt; [ 1, 2, 3, 4,  5, 6  ]</code></pre>
</section>
<section id="task.arraynize" class="level2">
<h2>Task.arraynize()</h2>
<pre class="js"><code>var source = [1,2,3];
source[&quot;key&quot;] = &quot;value&quot;; // 配列にプロパティを追加

Task.arraynize(source);  // -&gt; [1, 2, 3]</code></pre>
<ul>
<li><strong>Task.arraynize(source)</strong>は、新しい配列を作り source の値をコピーします</li>
<li><strong>数字の添字を持たないプロパティはコピーしません</strong><br /> <strong>task.set(&quot;key&quot;, &quot;value&quot;)</strong> で設定した<br /> <strong>{ &quot;key&quot;: &quot;value&quot; }</strong> は <strong>捨てられます</strong></li>
<li>Array + Object な source を Array としてクローンする(フィルタリングする)汎用関数として利用できます</li>
</ul>
</section>
<section id="task.objectize" class="level2">
<h2>Task.objectize()</h2>
<pre class="js"><code>var source = [1,2,3];
source[&quot;key&quot;] = &quot;value&quot;; // 配列にプロパティを追加
Object.keys(source);     // -&gt; [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;key&quot;]

Task.objectize(source);  // -&gt; { 0: 1, 1: 2, 2: 3, key: &quot;value&quot; }

</code></pre>
<ul>
<li><strong>Task.objectize(source)</strong>は、新しい Object を作り Object.keys(source) で見つかる要素を全てコピーして返します</li>
<li><strong>task.set(&quot;key&quot;, &quot;value&quot;)</strong> で設定した<br /> <strong>{ &quot;key&quot;: &quot;value&quot; }</strong> も <strong>コピーします</strong></li>
<li>Array + Object な source を Object としてクローンする(Object に再構築する)汎用関数として利用できます</li>
</ul>
<!-- ----------------------------------------------------- -->
</section>
</section>
<section id="デバッグする" class="level1">
<h1>デバッグする</h1>
<section id="task.dump" class="level2">
<h2>Task.dump()</h2>
<pre class="js"><code>var task1 = new Task(1, function(){});
var task2 = new Task(1, function(){});
var task3 = new Task(1, function(){});

Task.dump();
{
    &quot;anonymous@1&quot;: { junction: false, taskCount: 1, missableCount: 0, missedCount: 0, passedCount: 0, state: &quot;&quot; }
    &quot;anonymous@2&quot;: { junction: false, taskCount: 1, missableCount: 0, missedCount: 0, passedCount: 0, state: &quot;&quot; }
    &quot;anonymous@3&quot;: { junction: false, taskCount: 1, missableCount: 0, missedCount: 0, passedCount: 0, state: &quot;&quot; }
}</code></pre>
<script>
function task_dump() {
    Task.drop();
    var task1 = new Task(1, function(){});
    var task2 = new Task(1, function(){});
    var task3 = new Task(1, function(){});
    alert(JSON.stringify(Task.dump(), null, 2));
}
</script>

<button style="font:normal 24pt Impact" onclick="task_dump()">
run Task.dump()
</button>

<ul>
<li><strong>Task.dump()</strong> は Task のスナップショットを返します</li>
<li>実行中の Task 名と、内部の状態を把握できます</li>
</ul>
</section>
<section id="task.dumpタスク名による絞込" class="level2">
<h2>Task.dump(タスク名による絞込)</h2>
<pre class="js"><code>var task = new Task(1, callback, { name: &quot;TEST&quot; });

Task.dump(&quot;TEST&quot;);
{
    &quot;TEST@166&quot;: { junction: false, taskCount: 1, missableCount: 0,
                  missedCount: 0, passedCount: 0, state: &quot;&quot; }
}</code></pre>
<ul>
<li>Task の第三引数で Task 名を指定し、<strong>Task.dump(taskName)</strong> で絞り込めます</li>
</ul>
</section>
<section id="task.drop" class="level2">
<h2>Task.drop()</h2>
<pre class="js"><code>Task.drop(); // この行以前の Task のスナップショットを削除

var task = new Task(1, function() {}, { name: &quot;debug&quot; });

Task.dump();
{
    &quot;debug@1&quot;: { junction: false, taskCount: 1, missableCount: 0,
                 passedCount: 0, missedCount: 0, state: &quot;&quot; }
}</code></pre>
<ul>
<li><strong>Task.drop()</strong> は、<br /> Task.dump() 用の情報をリセット(削除)します<br /></li>
<li>この関数はデバッグ/テスト用です。<br /> 通常利用で明示的に呼ぶ必要はありません</li>
</ul>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="task.exit" class="level1">
<h1>task.exit()</h1>
<pre class="js"><code>function callback(error) { }

var task = new Task(100, callback).missable(100);

task.exit(); // 強制的に待機終了にする -&gt; callback(new Error(...))</code></pre>
<section id="section-9" class="level2">
<h2></h2>
<ul>
<li><strong>task.exit()</strong> を使うと、 ユーザのタスク数や missable の状態に関わらず、強制的に待機失敗で終了します</li>
</ul>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="task.state-task.isfinished" class="level1">
<h1>task.state(), task.isFinished()</h1>
<pre class="js"><code>var task = new Task(1);

task.isFinished(); // -&gt; false
task.state();      // -&gt; &quot;&quot;
task.pass();       // 待機終了
task.isFinished(); // -&gt; true
task.state();      // -&gt; &quot;pass&quot;</code></pre>
<section id="section-10" class="level2">
<h2></h2>
<ul>
<li><strong>task.state()</strong> は Task の状態を文字列で返します</li>
<li><strong>task.isFinished()</strong> は Task の待機終了で true を返します</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">task.state()</th>
<th style="text-align: left;">task.isFinished()</th>
<th style="text-align: left;">状態</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">&quot;&quot;</td>
<td style="text-align: left;">flase</td>
<td style="text-align: left;">待機中</td>
</tr>
<tr class="even">
<td style="text-align: left;">&quot;pass&quot;</td>
<td style="text-align: left;">true</td>
<td style="text-align: left;">待機成功で終了</td>
</tr>
<tr class="odd">
<td style="text-align: left;">&quot;miss&quot;</td>
<td style="text-align: left;">true</td>
<td style="text-align: left;">待機失敗で終了</td>
</tr>
<tr class="even">
<td style="text-align: left;">&quot;exit&quot;</td>
<td style="text-align: left;">true</td>
<td style="text-align: left;">待機失敗で終了</td>
</tr>
</tbody>
</table>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="task.message-task.doneerror" class="level1">
<h1>task.message(), task.done(error)</h1>
<section id="error-handling" class="level2">
<h2>Error Handling</h2>
<pre class="js"><code>var task = new Task(1, function(error) {
    if (error) { console.log(error.message); } // -&gt; &quot;O_o&quot;
});

function userTask(task) {
    try {
        throw new Error(&quot;O_o&quot;); // 例外発生!
        task.pass(); // ここには到達しない
    } catch (error) {
        task.message(error.message).miss(); // task.message(&quot;O_o&quot;) を設定
    }
}
userTask(task);</code></pre>
<ul>
<li>エラーのハンドリングはユーザタスク側で行い、<br /> <strong>task.miss()</strong> を呼んでください</li>
<li><strong>task.message( &quot;メッセージ&quot; )</strong>.<strong>miss()</strong> とすると、<br /> callback( <strong>new Error(&quot;メッセージ&quot;)</strong> ) として伝達します</li>
</ul>
</section>
<section id="section-11" class="level2">
<h2></h2>
<ul>
<li><strong>task.done</strong> は、<strong>task.pass()</strong> と <strong>task.miss()</strong> のコンビニエントメソッドです。 <strong>task.pass()</strong> または <strong>task.miss()</strong> を呼び分けている処理をシンプルに記述できます</li>
<li><strong>task.done(Errorオブジェクト)</strong> は <strong>task.message(error.message).miss()</strong> として動作し、 <strong>task.done(...)</strong> は <strong>task.pass()</strong> として動作します</li>
</ul>
<pre class="js"><code>// このようなありがちなコードを
if (error) { // Error Object
    task.message(error.message).miss();
} else {
    task.pass();
}</code></pre>
<pre class="js"><code>// 短く記述できます
task.done(error);</code></pre>
<!-- ----------------------------------------------------- -->
</section>
</section>
<section id="task.missable" class="level1">
<h1>task.missable()</h1>
<section id="失敗を許容する織り込んでおく" class="level2">
<h2>失敗を許容する(織り込んでおく)</h2>
<pre class="js"><code>function callback(error) { console.log(error.message); }

var task = new Task(1, callback, { name: &quot;MissableTask&quot; });

task.missable(2); // 2回までの失敗を許容する(3回失敗したら終了する)
task.miss(); // ユーザタスク失敗(1回目の失敗なので継続する)
task.miss(); // ユーザタスク失敗(2回目の失敗なので継続する)
task.miss(); // ユーザタスク失敗(3回目の失敗なので待機失敗で終了する) -&gt; callback(Error)</code></pre>
<ul>
<li>成功すべきユーザタスクが1つあり、<br /> 2回までの失敗を許す場合は、<br /> new Task(1).<strong>missable(2)</strong> とします</li>
<li>task.missable(2) は3回失敗すると待機失敗で終了します</li>
<li>task 生成時の初期値は task.missble(0) です</li>
<li>task.missable(0) の状態で <strong>task.miss()</strong> を一度でも呼ぶと待機失敗で終了します</li>
</ul>
</section>
<section id="section-12" class="level2">
<h2></h2>
<pre class="js"><code>// CDN1 からダウンロードできない場合に
// CDN2 を利用してリカバリを試みる
function callback(error) { console.log(error.message); }
var urls = [&quot;http://cdn1.example.com/image.png&quot;,
            &quot;http://cdn2.example.com/image.png&quot;];

download( urls, new Task(urls.length, callback).missable(1) );

function download(urls, task) {
    var xhr = new XMLHttpRequest();

    xhr.onload = function() { task.pass(); };
    xhr.onerror = function() {
        // CDN1 失敗 ▶ タスク継続中? ▶ ダウンロードを続行
        if ( !task.miss().isFinished() ) {
            download(urls, task);
        }
    };
    xhr.open(&quot;GET&quot;, urls.shift(), true);
    xhr.send()
}</code></pre>
<ul>
<li>task.missable を使うと「<strong>こんなこともあろうかと</strong>」を<br /> とても簡単に実装できます</li>
</ul>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="task.extend" class="level1">
<h1>task.extend()</h1>
<pre class="js"><code>function callback(error) { }

var taskCount = 1;
var task = new Task(taskCount, callback);

task.extend(1); // taskCount += 1;
task.pass();    // ユーザタスク成功(taskCount は2なので待機する)
task.pass();    // ユーザタスク成功(taskCount は2なので待機成功で終了する)
                //      -&gt; callback(null)</code></pre>
<ul>
<li>動的に待機数(taskCount)を +1 するには、<br /> <strong>task.extend(1)</strong> とします</li>
<li>次々にユーザタスクが増えるケースで使います</li>
</ul>
<figure>
<img src="./assets/img/task.extend.png" />
</figure>
<!-- ----------------------------------------------------- -->

</section>
<section id="junction" class="level1">
<h1>Junction</h1>
<section id="section-13" class="level2">
<h2></h2>
<div style="background: url(./assets/img/junction.png) right top no-repeat">
<div style="max-width: 600px; min-height:220px">
<pre class="js"><code>function callback(error) {
    console.log(&quot;finished&quot;);
}

var junction = new Task(2, callback);

var task1 = new Task(1, junction);
var task2 = new Task(1, junction);

task1.pass(); // →junction にも状態変化が通知される
task2.pass(); // →junction にも状態変化が通知される
              // →junction の待機も終了する</code></pre>
</div>
</div>
<ul>
<li>Task を集約する Task を <strong>Junction(合流点)</strong> と呼びます</li>
<li>Junction に Junction を重ねる事で<br /> 階層構造( <strong>Junction Tree</strong> )を作る事も可能です</li>
<li>下位の Junction/Task で <strong>状態変化</strong> が起きると、上位の Junction にも <strong>通知</strong> されます。 さらに上位の Junction がある場合は <strong>次々に伝播</strong> (バブルアップ)します</li>
</ul>
</section>
<section id="section-14" class="level2">
<h2></h2>
<div style="background: url(./assets/img/junction.png) right top no-repeat">
<div style="max-width: 600px; min-height:220px">
<pre class="js"><code>function callback(error) {
    console.log(&quot;finished&quot;);
}

var junction = new Task(2, callback);

var task1 = new Task(1, junction);
var task2 = new Task(1, junction);

task1.pass(); // →junction にも状態変化が通知される
task2.pass(); // →junction にも状態変化が通知される
              // →junction の待機も終了する</code></pre>
</div>
</div>
<ul>
<li>task1.pass() で task1 と junction の状態が変化します</li>
<li>task2.pass() で task2 と junction の状態が変化します</li>
<li>task2.pass() のタイミングで junction の待機も終了し、callback が呼ばれます</li>
</ul>
</section>
<section id="junction-tree" class="level2">
<h2>Junction Tree</h2>
<div style="background: url(./assets/img/nested.junction.png) right top no-repeat">
<div style="max-width: 525px; min-height:320px">
<pre class="js"><code>function callback(error) {
    console.log(&quot;finished&quot;);
}

lv1_junction     = new Task(1, callback);
  lv2_junction   = new Task(1, lv1_junction);
    lv3_junction = new Task(2, lv2_junction);
      lv4_task1  = new Task(1, lv3_junction);
      lv4_task2  = new Task(1, lv3_junction);

lv4_task1.pass();
lv4_task2.pass();</code></pre>
</div>
</div>
<ul>
<li>Junction を使うことで Task の階層構造をコンパクトに記述できます</li>
</ul>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="task.run" class="level1">
<h1>Task.run</h1>
<section id="section-15" class="level2">
<h2></h2>
<pre class="js"><code>function callback(error, buffer) {
}

Task.run(&quot;task_a &gt; task_b + task_c &gt; task_d&quot;, {
    task_a: function(task) { task.pass(); },
    task_b: function(task) { task.pass(); },
    task_c: function(task) { task.pass(); },
    task_d: function(task) { task.pass(); }
}, callback);</code></pre>
<ul>
<li><strong>Task.run</strong> は ユーザタスクの前後関係を定義し<br /> 実行する機能(ユーザタスク・ランナー)です</li>
<li>ユーザタスク名を <strong><code>&gt;</code></strong> と <strong><code>+</code></strong> でつなぐ事で、<br /> ユーザタスクの前後の流れ(直列/並列動作)を定義します</li>
<li>Task.run から起動されるユーザタスクの第一引数には<br /> <strong>Task</strong> のインスタンスが渡されます</li>
</ul>
</section>
<section id="task.run-junction" class="level2">
<h2>Task.run + Junction</h2>
<pre class="js"><code>var taskMap = {
    a: function(task) { task.pass(); },
    b: function(task) { task.pass(); },
    c: function(task) { task.pass(); },
    d: function(task) { task.pass(); },
};

var junction = new Task(2, callback); // (a &gt; b) + (c + d) が終わったら callback

Task.run(&quot;a &gt; b&quot;, taskMap, junction); // a を実行後に b を実行
Task.run(&quot;c + d&quot;, taskMap, junction); // c と d を並列実行</code></pre>
<ul>
<li>Task の上下関係を定義する <strong>Junction</strong> と<br /> ユーザタスクの前後関係を定義する Task.run を<br /> 組み合わせて利用することも可能です</li>
</ul>
</section>
<section id="ユーザタスクの並列化" class="level2">
<h2>ユーザタスクの並列化</h2>
<pre class="js"><code>
Task.run(&quot;task_a + task_b&quot;, {
    task_a: function(task) { task.pass(); },
    task_b: function(task) { task.pass(); },
}, callback);</code></pre>
<ul>
<li>ユーザタスク を <strong><code>+</code></strong> でつなぐと、<br /> それらは並列に実行します</li>
</ul>
</section>
<section id="ユーザタスクの直列化" class="level2">
<h2>ユーザタスクの直列化</h2>
<pre class="js"><code>Task.run(&quot;task_a &gt; task_b&quot;, {
    task_a: function(task) { task.pass(); },
    task_b: function(task) { task.pass(); },
}, callback);</code></pre>
<ul>
<li>ユーザタスクを <strong><code>&gt;</code></strong> でつなぐと、<br /> それらは直列(順番)に実行します</li>
</ul>
</section>
<section id="sleepタスク" class="level2">
<h2>sleepタスク</h2>
<pre class="js"><code>Task.run(&quot;task_a &gt; 1000 &gt; task_b&quot;, {
    task_a: function(task) { task.pass(); },
    task_b: function(task) { task.pass(); },
}, callback);</code></pre>
<ul>
<li>タスク名の代わりにms単位の数字を埋め込むと、<br /> 指定した時間分だけ待機する<br /> <strong>何もしない</strong> タスクを内部で生成します</li>
<li>時間稼ぎができます</li>
<li>上記の例では、task_a 実行後に <strong>1000ms</strong> 待機し、<br /> その後に task_b を実行します</li>
</ul>
</section>
<section id="直列化したタスクの省略記法" class="level2">
<h2>直列化したタスクの省略記法</h2>
<pre class="js"><code>function task_a(task) { task.pass(); }
function task_b(task) { task.pass(); }
function task_c(task) { task.pass(); }

// このように順番に実行するだけのユーザタスクは...
Task.run(&quot;task_a &gt; task_b &gt; task_c&quot;, {
    task_a: task_a,
    task_b: task_b,
    task_c: task_c,
}, callback);

// シンプルに書くことができます
Task.run(&quot;&quot;, [task_a, task_b, task_c], callback);</code></pre>
<ul>
<li>第一引数を省略し、第二引数にユーザタスクの配列を指定すると、直列タスクとして順番に実行します</li>
</ul>
</section>
<section id="直列並列sleepを組み合わせる" class="level2">
<h2>直列/並列/sleepを組み合わせる</h2>
<pre class="js"><code>Task.run(&quot;a &gt; b + c + 1000 &gt; d&quot;, {
    a: function(task) { task.pass(); },
    b: function(task) { task.pass(); },
    c: function(task) { task.pass(); },
    d: function(task) { task.pass(); }
}, callback);</code></pre>
<ul>
<li><strong><code>a &gt; b + c + 1000 &gt; d</code></strong> は、ユーザタスク a 〜 d を以下の順番で実行します
<ol type="1">
<li>a を実行します</li>
<li>a の正常終了で、b と c を並列に実行します</li>
<li>b と c が正常終了しており sleep(1000) が終わっているなら d を実行します</li>
<li>d が正常終了すると、callback を呼び出します</li>
</ol></li>
</ul>
</section>
<section id="ユーザタスクに引数を渡す" class="level2">
<h2>ユーザタスクに引数を渡す</h2>
<pre class="js"><code>var arg = { a: 1, b: 2, c : 3, d: 4 }; // ユーザタスクに渡す値

Task.run(&quot;task_a &gt; task_b + task_c &gt; task_d&quot;, {
    task_a: function(task, arg) { console.log(arg.a); task.pass(); },
                           ///                /////
    task_b: function(task, arg) { console.log(arg.b); task.pass(); },
    task_c: function(task, arg) { console.log(arg.c); task.pass(); },
    task_d: function(task, arg) { console.log(arg.d); task.pass(); },
}, function(error, buffer) {
    if (error) {
        console.log(&quot;ng&quot;);
    } else {
        console.log(&quot;ok&quot;);
    }
}, { arg: arg });
     ////////////////////////</code></pre>
<ul>
<li>Task.run から起動されるユーザタスク(task_a 〜 task_d)に引数を渡すには、Task.run の第四引数(options)に <strong>arg</strong> を設定します</li>
</ul>
</section>
<section id="直列化したユーザタスクの失敗" class="level2">
<h2>直列化したユーザタスクの失敗</h2>
<pre class="js"><code>Task.run(&quot;task_a &gt; task_b&quot;, {
    task_a: function(task) { task.miss(); },
    task_b: function(task) { task.pass(); }, // task_b は実行されません
}, callback);</code></pre>
<ul>
<li><strong>直列化</strong>したユーザタスクが <strong>途中で失敗</strong> すると後続のユーザタスクは <strong>実行しません</strong></li>
<li>task_a が失敗した場合は、後続の task_b は実行しません</li>
</ul>
</section>
<section id="並列化したユーザタスクの失敗" class="level2">
<h2>並列化したユーザタスクの失敗</h2>
<pre class="js"><code>Task.run(&quot;task_c + task_d + task_e&quot;, {
    task_c: function(task) {
        setTimeout(function() { task.miss() }, 1000); // 1000ms 後に失敗
    },
    task_d: function(task) { task.pass(); }, // task_c が中断しても task_d は中断しません
    task_e: function(task) { task.pass(); }, // task_c が中断しても task_e は中断しません
}, callback);</code></pre>
<ul>
<li><strong>並列化</strong>したユーザタスクの <strong>一部が失敗しても</strong> 、<br /> 同じグループに属するユーザタスクは <strong>中断しません</strong></li>
<li>task_c が途中で失敗した場合でも、task_d と task_e は中断しません</li>
</ul>
</section>
<section id="バリデーション" class="level2">
<h2>バリデーション</h2>
<pre class="js"><code>Task.run(&quot;task_a + task_b + task_c&quot;, { // task_a, task_b, task_c が存在しない ▶ エラー

    bad_argument: function(/* task */) {} // 引数を受け取らないユーザタスク ▶ エラー

}, function() {});</code></pre>
<pre class="js"><code>&gt; TypeError: Task.run(taskRoute, taskMap)</code></pre>
<ul>
<li>第一引数で指定したタスク名が存在しない場合や、<br /> 引数を受け取らないユーザタスクの存在を検出するとエラーになります</li>
</ul>
</section>
<section id="まとめ-1" class="level2">
<h2>まとめ</h2>
<ul>
<li>Task.run を使うと、<br /> 非同期処理をデータ化(文字列化)ができます</li>
<li>仕様変更が入りやすいアニメーションなどの非同期処理を Task.run で組んでおくと、 将来の仕様変更に対して一定の強度を持たせることができます</li>
</ul>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="非同期ループ" class="level1">
<h1>非同期ループ</h1>
<pre class="js"><code>var source = { a: 1, b: 2 };

Task.loop(source, function tick(task, key, source) {
    console.log(key, source[key]);
    task.pass();
}, function callback(error, buffer) {
    console.log(&quot;finished&quot;);
});

&gt; a 1
&gt; b 2
&gt; finished</code></pre>
<ul>
<li>Task.loop は非同期ループ機能を提供します</li>
<li>source には Object または Array を指定できます</li>
<li>key には Object.keys(source) が返す [key, ...] が順番に与えられます</li>
<li>tick の内部で task.pass() を実行するとループが進行し、<br /> task.miss() を実行するとループが中断します</li>
</ul>
<!-- ----------------------------------------------------- -->

</section>
<section id="javascript-vs-promise-vs-task.js" class="level1">
<h1>JavaScript vs Promise vs Task.js</h1>
<section id="section-16" class="level2">
<h2></h2>
<p>「非同期のユーザタスク <strong>A, B, C, D</strong> を、<br /><strong>A, B のグループ</strong> と <strong>C, D のグループ</strong> に分け、<br /><strong>2つのグループの完了を待つ</strong>」処理を、<br />それぞれの方法で実装してみます</p>
<ul>
<li>JavaScript</li>
<li>jQuery.Deferred</li>
<li>DOM Promise</li>
<li>Task.js ( Junction )</li>
<li>Task.js ( Junction + Task.run )</li>
</ul>
</section>
<section id="javascript-version" class="level2">
<h2>JavaScript Version</h2>
<pre class="js"><code>function waitForAsyncProcesses(finishedCallback) {
    var remainTaskGroupCount1 = [A, B].length; // 2
    var remainTaskGroupCount2 = [C, D].length; // 2
    var remainJunctionTaskCount = 2;

    function A() { setTimeout(function() { doneTaskGroup1(); }, 10);  }
    function B() { setTimeout(function() { doneTaskGroup1(); }, 100); }
    function C() { setTimeout(function() { doneTaskGroup2(); }, 20);  }
    function D() { setTimeout(function() { doneTaskGroup2(); }, 200); }

    function doneTaskGroup1() {
        if (--remainTaskGroupCount1 &lt;= 0) { junction(); }
    }
    function doneTaskGroup2() {
        if (--remainTaskGroupCount2 &lt;= 0) { junction(); }
    }
    function junction() {
        if (--remainJunctionTaskCount &lt;= 0) { finishedCallback(); }
    }
    A(); B(); C(); D();
}
waitForAsyncProcesses(function(error) { console.log(&quot;finished&quot;); });</code></pre>
</section>
<section id="jquery.deferred-version" class="level2">
<h2>jQuery.Deferred Version</h2>
<pre class="js"><code>function waitForAsyncProcesses(finishedCallback) {
    var promises1 = [A(), B()]; // 2
    var promises2 = [C(), D()]; // 2

    function A() {
        var dfd = jQuery.Deferred();
        setTimeout(function() { dfd.resolve(); }, 10);
        return dfd.promise();
    }
    function B() {
        var dfd = jQuery.Deferred();
        setTimeout(function() { dfd.resolve(); }, 100);
        return dfd.promise();
    }
    function C() {
        var dfd = jQuery.Deferred();
        setTimeout(function() { dfd.resolve(); }, 20);
        return dfd.promise();
    }
    function D() {
        var dfd = jQuery.Deferred();
        setTimeout(function() { dfd.resolve(); }, 200);
        return dfd.promise();
    }

    jQuery.when(
        jQuery.when.apply(null, promises1), // task group1
        jQuery.when.apply(null, promises2)  // task group2
    ).done(function() {
        finishedCallback()
    });
}
waitForAsyncProcesses(function(error) { console.log(&quot;finished&quot;); });</code></pre>
</section>
<section id="dom-promise-version" class="level2">
<h2>DOM Promise Version</h2>
<pre class="js"><code>function waitForAsyncProcesses(finishedCallback) {
    function A() {
        return new Promise(function(resolve, reject) { setTimeout(resolve, 10);  });
    }
    function B() {
        return new Promise(function(resolve, reject) { setTimeout(resolve, 100); });
    }
    function C() {
        return new Promise(function(resolve, reject) { setTimeout(resolve, 20);  });
    }
    function D() {
        return new Promise(function(resolve, reject) { setTimeout(resolve, 200); });
    }
    Promise.all([
        Promise.all([A(), B()]),
        Promise.all([C(), D()])
    ]).then(function() {
        finishedCallback(null);
    }).catch(function(error) {
        finishedCallback(error);
    });
}
waitForAsyncProcesses(function(error) { console.log(&quot;finished&quot;); })</code></pre>
</section>
<section id="task.js-junction-version" class="level2">
<h2>Task.js ( Junction ) Version</h2>
<pre class="js"><code>function waitForAsyncProcesses(finishedCallback) {
    var taskMap = {
            A: function(task) { setTimeout(function() { task.pass(); }, 10);  },
            B: function(task) { setTimeout(function() { task.pass(); }, 100); },
            C: function(task) { setTimeout(function() { task.pass(); }, 20);  },
            D: function(task) { setTimeout(function() { task.pass(); }, 200); },
        };
    var junction = new Task(2, finishedCallback);
    var taskGroup1 = new Task(2, junction);
    var taskGroup2 = new Task(2, junction);

    taskMap.A(taskGroup1);
    taskMap.B(taskGroup1);
    taskMap.C(taskGroup2);
    taskMap.D(taskGroup2);
}
waitForAsyncProcesses(function(error) { console.log(&quot;finished&quot;); });</code></pre>
<p>(ε・◇・)з o O ( <strong>スッキリ</strong></p>
</section>
<section id="task.js-junction-task.run-version" class="level2">
<h2>Task.js ( Junction + Task.run ) Version</h2>
<pre class="js"><code>function waitForAsyncProcesses(finishedCallback) {
    var taskMap = {
            A: function(task) { setTimeout(function() { task.pass(); }, 10);  },
            B: function(task) { setTimeout(function() { task.pass(); }, 100); },
            C: function(task) { setTimeout(function() { task.pass(); }, 20);  },
            D: function(task) { setTimeout(function() { task.pass(); }, 200); },
        };
    var junction = new Task(2, finishedCallback);

    Task.run(&quot;A + B&quot;, taskMap, junction);
    Task.run(&quot;C + D&quot;, taskMap, junction);
}

waitForAsyncProcesses(function(error) { console.log(&quot;finished&quot;); });</code></pre>
<p>(ε・◇・)з o O ( <strong>超スッキリ</strong></p>
<!-- ----------------------------------------------------- -->
</section>
</section>
<section id="try-it" class="level1">
<h1>Try it</h1>
<section id="section-17" class="level2">
<h2></h2>
<p>github</p>
<pre class="sh"><code>https://github.com/uupaa/Task.js</code></pre>
<p>npm</p>
<pre class="sh"><code>$ npm install uupaa.task.js</code></pre>
</section>
<section id="section-18" class="level2">
<h2></h2>
<p>Node.js</p>
<pre class="js"><code>var Task = require(&quot;uupaa.task.js&quot;);

var task = new Task(1, ...);</code></pre>
<p>Browser</p>
<pre class="js"><code>&lt;script src=&quot;uupaa.task.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
var task = new Task(1, ...);
&lt;/script&gt;</code></pre>
<p>WebWorkers</p>
<pre class="js"><code>importScripts(&quot;uupaa.task.js&quot;);

var task = new Task(1, ...);</code></pre>
</section>
<section id="in-this-slide" class="level2">
<h2>in this slide</h2>
<p>DevTools</p>
<pre class="js"><code>new Task(1, function() { console.log(&quot;Hello Task.js&quot;); }).pass();</code></pre>
<figure>
<img src="./assets/img/try.png" />
</figure>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="まとめ-2" class="level1">
<h1>まとめ</h1>
<section id="section-19" class="level2">
<h2></h2>
<p>Task.js は以下の特徴を備えています</p>
<ul>
<li><strong>様々な環境で動作</strong> します</li>
<li>構造が <strong>シンプル</strong> で応用が効きます</li>
<li>既存の構造やユーザのタスクを<br /> <strong>大きく改変しなくても導入可能</strong> です</li>
<li>Junction で <strong>上下関係を定義</strong> し、<br /> Task.run で <strong>前後関係を定義</strong> できます</li>
<li>Junction と Task.run を組み合わせて<br /> <strong>スッキリ</strong> としたコードが書けます</li>
</ul>
</section>
<section id="section-20" class="level2">
<h2></h2>
<p>(ε・◇・)з o O ( Task.js マジ オススメ</p>
</section>
</section>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>

<script>
  // Full list of configuration options available here:
  // https://github.com/hakimel/reveal.js#configuration
  Reveal.initialize({
    controls: true,
    progress: true,
    history: true,
    center: false,

  // available themes are in /css/theme
      theme: Reveal.getQueryHash().theme || 'default', 
  
  // default/cube/page/concave/zoom/linear/fade/none
      transition: Reveal.getQueryHash().transition || 'default',
  
  // Optional libraries used to extend on reveal.js
  dependencies: [
    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
    { src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
    // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
  ]
  });

</script>

</body>
</html>
